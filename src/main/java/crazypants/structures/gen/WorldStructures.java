package crazypants.structures.gen;

import java.io.File;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import crazypants.structures.Log;
import crazypants.structures.api.gen.IStructure;
import crazypants.structures.api.gen.IWorldStructures;
import crazypants.structures.gen.io.WorldData;
import crazypants.structures.gen.structure.Structure;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.world.ChunkCoordIntPair;
import net.minecraft.world.World;

public class WorldStructures implements IWorldStructures {

  private final Map<ChunkCoordIntPair, List<IStructure>> structures = new HashMap<ChunkCoordIntPair, List<IStructure>>();
  private final Map<ChunkCoordIntPair, List<IStructure>> structureCoverage = new HashMap<ChunkCoordIntPair, List<IStructure>>();

  private File structFile;

  private final World world;

  public WorldStructures(World world) {
    this.world = world;
    structFile = WorldData.INSTANCE.getNbtSaveFile(world, "structures");
  }

  @Override
  public World getWorld() {
    return world;
  }

  @Override
  public void add(IStructure s) {
    //    Log.info("WorldStructures: Structure: " + s.getTemplate().getUid() + " generated by " + s.getGenerator().getUid() + " at " + s.getOrigin());
    ChunkCoordIntPair key = s.getChunkCoord();
    if(!structures.containsKey(key)) {
      structures.put(key, new ArrayList<IStructure>(2));
    }
    structures.get(key).add(s);

    for (ChunkCoordIntPair chunk : s.getChunkBounds().getChunks()) {
      if(!structureCoverage.containsKey(chunk)) {
        structureCoverage.put(chunk, new ArrayList<IStructure>(2));
      }
      structureCoverage.get(chunk).add(s);
    }
  }

  @Override
  public void addAll(Collection<IStructure> structures) {
    for (IStructure s : structures) {
      add(s);
    }
  }

  @Override
  public Collection<IStructure> getStructuresWithOriginInChunk(ChunkCoordIntPair chunkPos) {
    List<IStructure> res = structures.get(chunkPos);
    if(res == null) {
      return Collections.emptyList();
    }
    return res;
  }

  @Override
  public Collection<IStructure> getStructuresWithOriginInChunk(ChunkCoordIntPair chunkPos, String templateUid) {
    List<IStructure> res = new ArrayList<IStructure>();
    getStructuresWithOriginInChunk(chunkPos, templateUid, res);
    return res;
  }

  @Override
  public void getStructuresWithOriginInChunk(ChunkCoordIntPair chunkPos, String templateUid, Collection<IStructure> result) {
    List<IStructure> all = structures.get(chunkPos);
    if(all == null) {
      return;
    }
    for (IStructure s : all) {
      if(templateUid == null || templateUid.equals(s.getUid())) {
        result.add(s);
      }
    }
  }

  @Override
  public void getStructuresIntersectingChunk(ChunkCoordIntPair chunk, String structureUid, Collection<IStructure> res) {
    List<IStructure> all = structureCoverage.get(chunk);
    if(all == null) {
      return;
    }
    for (IStructure s : all) {
      if(structureUid == null || structureUid.equals(s.getUid())) {
        res.add(s);
      }
    }
  }

  @Override
  public int getStructureCount() {
    int res = 0;    
    for(List<IStructure> str : structures.values()) {
      if(str != null) {
        res += str.size();
      }
    }
    return res;
  }
  
  public boolean contains(IStructure structure) {
    for(List<IStructure> str : structures.values()) {
      if(str != null && str.contains(structure)) {
        return true;
      }
    }
    return false;
  }

  public void writeToNBT(NBTTagCompound root) {
    NBTTagList structTags = new NBTTagList();
    for (List<IStructure> structs : structures.values()) {
      for (IStructure s : structs) {
        NBTTagCompound sTag = new NBTTagCompound();
        s.writeToNBT(sTag);
        structTags.appendTag(sTag);
      }
    }
    root.setTag("structures", structTags);
  }

  void loadStructuresFromNBT(NBTTagCompound root) {

    NBTTagList structTags = (NBTTagList) root.getTag("structures");
    if(structTags != null) {
      for (int i = 0; i < structTags.tagCount(); i++) {
        NBTTagCompound structTag = structTags.getCompoundTagAt(i);
        Structure s = new Structure(structTag);
        if(s.isValid()) {
          add(s);
        } else {
          Log.warn("WorldManager: Could not load structure " + s);
        }
      }
    }

    //    System.out.println("WorldStructures.loadStructuresFromNBT: ******************************* On Load: " + structures.size() + " : "
    //        + structureCoverage.size());

  }

  public void load() {    
    NBTTagCompound root = WorldData.INSTANCE.loadNBT(structFile);
    if(root != null) {
      loadStructuresFromNBT(root);
    }
  }

  public void save() {    
    NBTTagCompound root = new NBTTagCompound();
    writeToNBT(root);
    WorldData.INSTANCE.saveNBT(structFile, root);
  }

  

}