package crazypants.structures.gen;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.io.IOUtils;

import crazypants.structures.Log;
import crazypants.structures.api.gen.IStructure;
import crazypants.structures.api.gen.IWorldStructures;
import crazypants.structures.gen.structure.Structure;
import net.minecraft.nbt.CompressedStreamTools;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.world.ChunkCoordIntPair;
import net.minecraft.world.World;

public class WorldStructures implements IWorldStructures {

  private final Map<ChunkCoordIntPair, List<IStructure>> structures = new HashMap<ChunkCoordIntPair, List<IStructure>>();
  private final Map<ChunkCoordIntPair, List<IStructure>> structureCoverage = new HashMap<ChunkCoordIntPair, List<IStructure>>();

  private File structFile;
  
  private final World world;

  public WorldStructures(World world) {
    this.world = world;
    structFile = getWorldSaveFile(world);
  }

  @Override
  public World getWorld() {
    return world;
  }

  @Override
  public void add(IStructure s) {
//    Log.info("WorldStructures: Structure: " + s.getTemplate().getUid() + " generated by " + s.getGenerator().getUid() + " at " + s.getOrigin());
    ChunkCoordIntPair key = s.getChunkCoord();
    if(!structures.containsKey(key)) {
      structures.put(key, new ArrayList<IStructure>(2));
    }
    structures.get(key).add(s);

    for (ChunkCoordIntPair chunk : s.getChunkBounds().getChunks()) {
      if(!structureCoverage.containsKey(chunk)) {
        structureCoverage.put(chunk, new ArrayList<IStructure>(2));
      }
      structureCoverage.get(chunk).add(s);
    }
  }

  @Override
  public void addAll(Collection<IStructure> structures) {
//    if(!structures.isEmpty()) {
//      System.out.println("WorldStructures.addAll: " + StringUtils.join(structures, " ; "));
//    }
    for (IStructure s : structures) {
      add(s);
    }
  }

  @Override
  public Collection<IStructure> getStructuresWithOriginInChunk(ChunkCoordIntPair chunkPos) {
    List<IStructure> res = structures.get(chunkPos);
    if(res == null) {
      return Collections.emptyList();
    }
    return res;
  }

  @Override
  public Collection<IStructure> getStructuresWithOriginInChunk(ChunkCoordIntPair chunkPos, String templateUid) {
    List<IStructure> res = new ArrayList<IStructure>();
    getStructuresWithOriginInChunk(chunkPos, templateUid, res);
    return res;
  }

  @Override
  public void getStructuresWithOriginInChunk(ChunkCoordIntPair chunkPos, String templateUid, Collection<IStructure> result) {
    List<IStructure> all = structures.get(chunkPos);
    if(all == null) {
      return;
    }
    for (IStructure s : all) {
      if(templateUid == null || templateUid.equals(s.getUid())) {
        result.add(s);
      }
    }
  }

  @Override
  public void getStructuresIntersectingChunk(ChunkCoordIntPair chunk, String structureUid, Collection<IStructure> res) {
    List<IStructure> all = structureCoverage.get(chunk);
    if(all == null) {
      return;
    }
    for (IStructure s : all) {
      if(structureUid == null || structureUid.equals(s.getUid())) {
        res.add(s);
      }
    }
  }
  
  @Override
  public int getStructureCount() {
    return structures.size();
  }

  
  
  public void writeToNBT(NBTTagCompound root) {
    NBTTagList structTags = new NBTTagList();
    for (List<IStructure> structs : structures.values()) {
      for (IStructure s : structs) {
        NBTTagCompound sTag = new NBTTagCompound();
        s.writeToNBT(sTag);
        structTags.appendTag(sTag);
      }
    }
    root.setTag("structures", structTags);
  }

  void loadStructuresFromNBT(NBTTagCompound root) {

    NBTTagList structTags = (NBTTagList) root.getTag("structures");
    if(structTags != null) {
      for (int i = 0; i < structTags.tagCount(); i++) {
        NBTTagCompound structTag = structTags.getCompoundTagAt(i);
        Structure s = new Structure(structTag);
        if(s.isValid()) {
          add(s);
        } else {
          Log.warn("WorldManager: Could not load structure " + s);
        }
      }
    }

    //    System.out.println("WorldStructures.loadStructuresFromNBT: ******************************* On Load: " + structures.size() + " : "
    //        + structureCoverage.size());

  }

  public void load() {
    if(structFile == null) {
      return;
    }
    if(!structFile.exists()) {
      return;
    }
    FileInputStream fis = null;
    try {
      fis = new FileInputStream(structFile);
    } catch (Exception e) {
      Log.error("WorldManager: Could not open structure file for reading. File: " + structFile.getAbsolutePath());
      return;
    }

    try {
      NBTTagCompound root = CompressedStreamTools.read(new DataInputStream(fis));
      loadStructuresFromNBT(root);
    } catch (IOException e) {
      Log.error("WorldManager: Error reading structure file. File: " + structFile.getAbsolutePath() + " Exception: " + e);
      e.printStackTrace();
    } finally {
      IOUtils.closeQuietly(fis);
    }
  }

  public void save() {
    if(structFile == null) {
      return;
    }
    NBTTagCompound root = new NBTTagCompound();
    writeToNBT(root);

    FileOutputStream fos = null;
    try {
      fos = new FileOutputStream(structFile, false);
    } catch (FileNotFoundException e) {
      Log.error("WorldManager: could not open structure file for writing. File: " + structFile.getAbsolutePath());
      return;
    }

    try {
      CompressedStreamTools.write(root, new DataOutputStream(fos));
    } catch (IOException e) {
      Log.error("WorldManager: error writing to structure file: " + structFile.getAbsolutePath() + " Exception: " + e);
      e.printStackTrace();
    } finally {
      IOUtils.closeQuietly(fos);
    }

  }

  private File getWorldSaveDir(World world) {
    File dir = new File(world.getSaveHandler().getWorldDirectory(), "enderzoo");
    if(!dir.exists()) {
      if(!dir.mkdir()) {
        Log.error("WorldManager: Could not create structures directory: " + dir.getAbsolutePath());
      }
    }
    return dir;
  }

  private File getWorldSaveFile(World world) {
    File res = new File(getWorldSaveDir(world), "structures_dim" + world.provider.dimensionId + ".nbt");
    return res;
  }

}